/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.13.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AnimalService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getOwnedAnimals(userId: string, pageSize: number | undefined, pageIndex: number | undefined, isArchived: boolean | undefined): Observable<PagedListOfOwnedAnimalDto> {
        let url_ = this.baseUrl + "/api/animals/list/{userId}?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (isArchived === null)
            throw new Error("The parameter 'isArchived' cannot be null.");
        else if (isArchived !== undefined)
            url_ += "isArchived=" + encodeURIComponent("" + isArchived) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOwnedAnimals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOwnedAnimals(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfOwnedAnimalDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListOfOwnedAnimalDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOwnedAnimals(response: HttpResponseBase): Observable<PagedListOfOwnedAnimalDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PagedListOfOwnedAnimalDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListOfOwnedAnimalDto>(<any>null);
    }

    getAnimalsForSelect(userId: string): Observable<AnimalForSelectDto[]> {
        let url_ = this.baseUrl + "/api/animals/list/{userId}/select";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAnimalsForSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAnimalsForSelect(<any>response_);
                } catch (e) {
                    return <Observable<AnimalForSelectDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AnimalForSelectDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAnimalsForSelect(response: HttpResponseBase): Observable<AnimalForSelectDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AnimalForSelectDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AnimalForSelectDto[]>(<any>null);
    }

    createAnimal(userId: string, name: string | null | undefined, dateOfBirth: Date | null | undefined, sex: string | null | undefined, speciesId: string | undefined, photo: FileParameter | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/animals/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (dateOfBirth !== null && dateOfBirth !== undefined)
            content_.append("DateOfBirth", dateOfBirth.toJSON());
        if (sex !== null && sex !== undefined)
            content_.append("Sex", sex.toString());
        if (speciesId === null || speciesId === undefined)
            throw new Error("The parameter 'speciesId' cannot be null.");
        else
            content_.append("SpeciesId", speciesId.toString());
        if (photo !== null && photo !== undefined)
            content_.append("Photo", photo.data, photo.fileName ? photo.fileName : "Photo");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAnimal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAnimal(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAnimal(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    updateAnimal(animalId: string, data: UpdateAnimalCommandData): Observable<void> {
        let url_ = this.baseUrl + "/api/animals/{animalId}";
        if (animalId === undefined || animalId === null)
            throw new Error("The parameter 'animalId' must be defined.");
        url_ = url_.replace("{animalId}", encodeURIComponent("" + animalId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAnimal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAnimal(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAnimal(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getAnimal(animalId: string): Observable<AnimalDto> {
        let url_ = this.baseUrl + "/api/animals/{animalId}";
        if (animalId === undefined || animalId === null)
            throw new Error("The parameter 'animalId' must be defined.");
        url_ = url_.replace("{animalId}", encodeURIComponent("" + animalId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAnimal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAnimal(<any>response_);
                } catch (e) {
                    return <Observable<AnimalDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AnimalDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAnimal(response: HttpResponseBase): Observable<AnimalDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AnimalDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AnimalDto>(<any>null);
    }

    deleteAnimal(animalId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/animals/{animalId}";
        if (animalId === undefined || animalId === null)
            throw new Error("The parameter 'animalId' must be defined.");
        url_ = url_.replace("{animalId}", encodeURIComponent("" + animalId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAnimal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAnimal(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAnimal(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    deleteAnimalPhoto(animalId: string): Observable<string> {
        let url_ = this.baseUrl + "/api/animals/{animalId}/photo";
        if (animalId === undefined || animalId === null)
            throw new Error("The parameter 'animalId' must be defined.");
        url_ = url_.replace("{animalId}", encodeURIComponent("" + animalId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAnimalPhoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAnimalPhoto(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAnimalPhoto(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    updateAnimalPhoto(userId: string, animalId: string | undefined, photo: FileParameter | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/animals/{userId}/photo";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (animalId === null || animalId === undefined)
            throw new Error("The parameter 'animalId' cannot be null.");
        else
            content_.append("AnimalId", animalId.toString());
        if (photo !== null && photo !== undefined)
            content_.append("Photo", photo.data, photo.fileName ? photo.fileName : "Photo");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAnimalPhoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAnimalPhoto(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAnimalPhoto(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    updateAnimalArchiveStatus(animalId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/animals/{animalId}/status";
        if (animalId === undefined || animalId === null)
            throw new Error("The parameter 'animalId' must be defined.");
        url_ = url_.replace("{animalId}", encodeURIComponent("" + animalId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAnimalArchiveStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAnimalArchiveStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAnimalArchiveStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AppointmentService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getStatuses(): Observable<LabelValuePairOfAppointmentStatusEnum[]> {
        let url_ = this.baseUrl + "/api/appointments/statuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatuses(<any>response_);
                } catch (e) {
                    return <Observable<LabelValuePairOfAppointmentStatusEnum[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LabelValuePairOfAppointmentStatusEnum[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStatuses(response: HttpResponseBase): Observable<LabelValuePairOfAppointmentStatusEnum[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LabelValuePairOfAppointmentStatusEnum[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LabelValuePairOfAppointmentStatusEnum[]>(<any>null);
    }

    getDoctors(): Observable<DoctorForAppointmentDto[]> {
        let url_ = this.baseUrl + "/api/appointments/doctors";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDoctors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDoctors(<any>response_);
                } catch (e) {
                    return <Observable<DoctorForAppointmentDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DoctorForAppointmentDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDoctors(response: HttpResponseBase): Observable<DoctorForAppointmentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DoctorForAppointmentDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DoctorForAppointmentDto[]>(<any>null);
    }

    getDoctorTreatmentAvailableTimes(date: Date | undefined, doctorId: string | undefined, treatmentId: string | undefined): Observable<AvailableTime[]> {
        let url_ = this.baseUrl + "/api/appointments/available-times?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&";
        if (doctorId === null)
            throw new Error("The parameter 'doctorId' cannot be null.");
        else if (doctorId !== undefined)
            url_ += "doctorId=" + encodeURIComponent("" + doctorId) + "&";
        if (treatmentId === null)
            throw new Error("The parameter 'treatmentId' cannot be null.");
        else if (treatmentId !== undefined)
            url_ += "treatmentId=" + encodeURIComponent("" + treatmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDoctorTreatmentAvailableTimes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDoctorTreatmentAvailableTimes(<any>response_);
                } catch (e) {
                    return <Observable<AvailableTime[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AvailableTime[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDoctorTreatmentAvailableTimes(response: HttpResponseBase): Observable<AvailableTime[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AvailableTime[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AvailableTime[]>(<any>null);
    }

    bookAnAppointment(command: CreateAppointmentCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/appointments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBookAnAppointment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBookAnAppointment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBookAnAppointment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getAppointmentsForDoctor(doctorId: string | undefined, fromToday: boolean | undefined, pageData_PageSize: number | undefined, pageData_PageIndex: number | undefined): Observable<PagedListOfAppointmentForDoctorDto> {
        let url_ = this.baseUrl + "/api/appointments/list/doctor?";
        if (doctorId === null)
            throw new Error("The parameter 'doctorId' cannot be null.");
        else if (doctorId !== undefined)
            url_ += "DoctorId=" + encodeURIComponent("" + doctorId) + "&";
        if (fromToday === null)
            throw new Error("The parameter 'fromToday' cannot be null.");
        else if (fromToday !== undefined)
            url_ += "FromToday=" + encodeURIComponent("" + fromToday) + "&";
        if (pageData_PageSize === null)
            throw new Error("The parameter 'pageData_PageSize' cannot be null.");
        else if (pageData_PageSize !== undefined)
            url_ += "PageData.PageSize=" + encodeURIComponent("" + pageData_PageSize) + "&";
        if (pageData_PageIndex === null)
            throw new Error("The parameter 'pageData_PageIndex' cannot be null.");
        else if (pageData_PageIndex !== undefined)
            url_ += "PageData.PageIndex=" + encodeURIComponent("" + pageData_PageIndex) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppointmentsForDoctor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppointmentsForDoctor(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfAppointmentForDoctorDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListOfAppointmentForDoctorDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppointmentsForDoctor(response: HttpResponseBase): Observable<PagedListOfAppointmentForDoctorDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PagedListOfAppointmentForDoctorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListOfAppointmentForDoctorDto>(<any>null);
    }

    getAppointmentsForUser(userId: string | undefined, animalId: string | null | undefined, pageData_PageSize: number | undefined, pageData_PageIndex: number | undefined): Observable<PagedListOfAppointmentForUserDto> {
        let url_ = this.baseUrl + "/api/appointments/list/user?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (animalId !== undefined && animalId !== null)
            url_ += "AnimalId=" + encodeURIComponent("" + animalId) + "&";
        if (pageData_PageSize === null)
            throw new Error("The parameter 'pageData_PageSize' cannot be null.");
        else if (pageData_PageSize !== undefined)
            url_ += "PageData.PageSize=" + encodeURIComponent("" + pageData_PageSize) + "&";
        if (pageData_PageIndex === null)
            throw new Error("The parameter 'pageData_PageIndex' cannot be null.");
        else if (pageData_PageIndex !== undefined)
            url_ += "PageData.PageIndex=" + encodeURIComponent("" + pageData_PageIndex) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppointmentsForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppointmentsForUser(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfAppointmentForUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListOfAppointmentForUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppointmentsForUser(response: HttpResponseBase): Observable<PagedListOfAppointmentForUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PagedListOfAppointmentForUserDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListOfAppointmentForUserDto>(<any>null);
    }

    updateAppointmentStatus(command: UpdateAppointmentStatusCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/appointments/status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAppointmentStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAppointmentStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAppointmentStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class HolidayService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getHolidays(doctorId: string, pageSize: number | undefined, pageIndex: number | undefined): Observable<PagedListOfHolidayDto> {
        let url_ = this.baseUrl + "/api/holidays/list/{doctorId}?";
        if (doctorId === undefined || doctorId === null)
            throw new Error("The parameter 'doctorId' must be defined.");
        url_ = url_.replace("{doctorId}", encodeURIComponent("" + doctorId));
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHolidays(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHolidays(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfHolidayDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListOfHolidayDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetHolidays(response: HttpResponseBase): Observable<PagedListOfHolidayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PagedListOfHolidayDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListOfHolidayDto>(<any>null);
    }

    createHoliday(data: CreateHolidayCommandData): Observable<HolidayDto> {
        let url_ = this.baseUrl + "/api/holidays";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateHoliday(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateHoliday(<any>response_);
                } catch (e) {
                    return <Observable<HolidayDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HolidayDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateHoliday(response: HttpResponseBase): Observable<HolidayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <HolidayDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HolidayDto>(<any>null);
    }

    updateHoliday(data: UpdateHolidayCommandData): Observable<void> {
        let url_ = this.baseUrl + "/api/holidays";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateHoliday(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateHoliday(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateHoliday(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    deleteHoliday(holidayId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/holidays?";
        if (holidayId === null)
            throw new Error("The parameter 'holidayId' cannot be null.");
        else if (holidayId !== undefined)
            url_ += "HolidayId=" + encodeURIComponent("" + holidayId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteHoliday(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteHoliday(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteHoliday(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getDoctorHolidaysByInterval(doctorId: string | undefined, date: Date | undefined, duration: number | undefined): Observable<HolidayDto[]> {
        let url_ = this.baseUrl + "/api/holidays/intervals?";
        if (doctorId === null)
            throw new Error("The parameter 'doctorId' cannot be null.");
        else if (doctorId !== undefined)
            url_ += "DoctorId=" + encodeURIComponent("" + doctorId) + "&";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "Date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&";
        if (duration === null)
            throw new Error("The parameter 'duration' cannot be null.");
        else if (duration !== undefined)
            url_ += "Duration=" + encodeURIComponent("" + duration) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDoctorHolidaysByInterval(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDoctorHolidaysByInterval(<any>response_);
                } catch (e) {
                    return <Observable<HolidayDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HolidayDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDoctorHolidaysByInterval(response: HttpResponseBase): Observable<HolidayDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <HolidayDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HolidayDto[]>(<any>null);
    }
}

@Injectable()
export class MedicalRecordService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    generatePDF(recordId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/records/pdf/{recordId}";
        if (recordId === undefined || recordId === null)
            throw new Error("The parameter 'recordId' must be defined.");
        url_ = url_.replace("{recordId}", encodeURIComponent("" + recordId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneratePDF(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneratePDF(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGeneratePDF(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getMedicalRecordsForAnimal(animalId: string | undefined, pageData_PageSize: number | undefined, pageData_PageIndex: number | undefined): Observable<PagedListOfMedicalRecordDto> {
        let url_ = this.baseUrl + "/api/records/details/animal?";
        if (animalId === null)
            throw new Error("The parameter 'animalId' cannot be null.");
        else if (animalId !== undefined)
            url_ += "AnimalId=" + encodeURIComponent("" + animalId) + "&";
        if (pageData_PageSize === null)
            throw new Error("The parameter 'pageData_PageSize' cannot be null.");
        else if (pageData_PageSize !== undefined)
            url_ += "PageData.PageSize=" + encodeURIComponent("" + pageData_PageSize) + "&";
        if (pageData_PageIndex === null)
            throw new Error("The parameter 'pageData_PageIndex' cannot be null.");
        else if (pageData_PageIndex !== undefined)
            url_ += "PageData.PageIndex=" + encodeURIComponent("" + pageData_PageIndex) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMedicalRecordsForAnimal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMedicalRecordsForAnimal(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfMedicalRecordDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListOfMedicalRecordDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMedicalRecordsForAnimal(response: HttpResponseBase): Observable<PagedListOfMedicalRecordDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PagedListOfMedicalRecordDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListOfMedicalRecordDto>(<any>null);
    }

    getMedicalRecordsForUser(userId: string | undefined, pageData_PageSize: number | undefined, pageData_PageIndex: number | undefined): Observable<PagedListOfMedicalRecordDto> {
        let url_ = this.baseUrl + "/api/records/details/user?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (pageData_PageSize === null)
            throw new Error("The parameter 'pageData_PageSize' cannot be null.");
        else if (pageData_PageSize !== undefined)
            url_ += "PageData.PageSize=" + encodeURIComponent("" + pageData_PageSize) + "&";
        if (pageData_PageIndex === null)
            throw new Error("The parameter 'pageData_PageIndex' cannot be null.");
        else if (pageData_PageIndex !== undefined)
            url_ += "PageData.PageIndex=" + encodeURIComponent("" + pageData_PageIndex) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMedicalRecordsForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMedicalRecordsForUser(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfMedicalRecordDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListOfMedicalRecordDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMedicalRecordsForUser(response: HttpResponseBase): Observable<PagedListOfMedicalRecordDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PagedListOfMedicalRecordDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListOfMedicalRecordDto>(<any>null);
    }

    getMedicalRecordsDetails(recordId: string | undefined): Observable<MedicalRecordEditDto> {
        let url_ = this.baseUrl + "/api/records/details?";
        if (recordId === null)
            throw new Error("The parameter 'recordId' cannot be null.");
        else if (recordId !== undefined)
            url_ += "RecordId=" + encodeURIComponent("" + recordId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMedicalRecordsDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMedicalRecordsDetails(<any>response_);
                } catch (e) {
                    return <Observable<MedicalRecordEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MedicalRecordEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMedicalRecordsDetails(response: HttpResponseBase): Observable<MedicalRecordEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MedicalRecordEditDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MedicalRecordEditDto>(<any>null);
    }

    removePhotoFromRecord(recordId: string | undefined, photoId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/records/photo?";
        if (recordId === null)
            throw new Error("The parameter 'recordId' cannot be null.");
        else if (recordId !== undefined)
            url_ += "RecordId=" + encodeURIComponent("" + recordId) + "&";
        if (photoId === null)
            throw new Error("The parameter 'photoId' cannot be null.");
        else if (photoId !== undefined)
            url_ += "PhotoId=" + encodeURIComponent("" + photoId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovePhotoFromRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovePhotoFromRecord(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovePhotoFromRecord(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getAppointmentDetails(appointmentId: string): Observable<AppointmentForRecordDto> {
        let url_ = this.baseUrl + "/api/records/appointment-details/{appointmentId}";
        if (appointmentId === undefined || appointmentId === null)
            throw new Error("The parameter 'appointmentId' must be defined.");
        url_ = url_.replace("{appointmentId}", encodeURIComponent("" + appointmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppointmentDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppointmentDetails(<any>response_);
                } catch (e) {
                    return <Observable<AppointmentForRecordDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppointmentForRecordDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppointmentDetails(response: HttpResponseBase): Observable<AppointmentForRecordDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AppointmentForRecordDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppointmentForRecordDto>(<any>null);
    }

    createMedicalRecord(command: CreateMedicalRecordCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/records";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMedicalRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMedicalRecord(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMedicalRecord(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    updateMedicalRecord(command: UpdateMedicalRecordCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/records";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMedicalRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMedicalRecord(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMedicalRecord(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    addPhoto(recordId: string, photo: FileParameter | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/records/add-photo/{recordId}";
        if (recordId === undefined || recordId === null)
            throw new Error("The parameter 'recordId' must be defined.");
        url_ = url_.replace("{recordId}", encodeURIComponent("" + recordId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (photo !== null && photo !== undefined)
            content_.append("photo", photo.data, photo.fileName ? photo.fileName : "photo");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPhoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPhoto(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddPhoto(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MedicationService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    searchMedication(searchParam: string | null | undefined): Observable<MedicationForSelectDto[]> {
        let url_ = this.baseUrl + "/api/medications/search?";
        if (searchParam !== undefined && searchParam !== null)
            url_ += "searchParam=" + encodeURIComponent("" + searchParam) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchMedication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchMedication(<any>response_);
                } catch (e) {
                    return <Observable<MedicationForSelectDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MedicationForSelectDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processSearchMedication(response: HttpResponseBase): Observable<MedicationForSelectDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MedicationForSelectDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MedicationForSelectDto[]>(<any>null);
    }

    getMedicationsWithDetails(pageSize: number | undefined, pageIndex: number | undefined): Observable<PagedListOfMedicationDto> {
        let url_ = this.baseUrl + "/api/medications?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMedicationsWithDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMedicationsWithDetails(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfMedicationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListOfMedicationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMedicationsWithDetails(response: HttpResponseBase): Observable<PagedListOfMedicationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PagedListOfMedicationDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListOfMedicationDto>(<any>null);
    }

    createMedication(data: CreateMedicationCommandData): Observable<MedicationDto> {
        let url_ = this.baseUrl + "/api/medications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMedication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMedication(<any>response_);
                } catch (e) {
                    return <Observable<MedicationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MedicationDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMedication(response: HttpResponseBase): Observable<MedicationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MedicationDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MedicationDto>(<any>null);
    }

    updateMedication(data: UpdateMedicationCommandData): Observable<void> {
        let url_ = this.baseUrl + "/api/medications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMedication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMedication(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMedication(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    updateMedicationStatus(medicationId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/medications?";
        if (medicationId === null)
            throw new Error("The parameter 'medicationId' cannot be null.");
        else if (medicationId !== undefined)
            url_ += "medicationId=" + encodeURIComponent("" + medicationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMedicationStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMedicationStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMedicationStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    deleteMedication(medicationId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/medications?";
        if (medicationId === null)
            throw new Error("The parameter 'medicationId' cannot be null.");
        else if (medicationId !== undefined)
            url_ += "medicationId=" + encodeURIComponent("" + medicationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMedication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMedication(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMedication(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SpeciesService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAnimalSpecies(): Observable<AnimalSpeciesDto[]> {
        let url_ = this.baseUrl + "/api/species";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAnimalSpecies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAnimalSpecies(<any>response_);
                } catch (e) {
                    return <Observable<AnimalSpeciesDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AnimalSpeciesDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAnimalSpecies(response: HttpResponseBase): Observable<AnimalSpeciesDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AnimalSpeciesDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AnimalSpeciesDto[]>(<any>null);
    }

    createAnimalSpecies(name: string | null | undefined): Observable<AnimalSpeciesDto> {
        let url_ = this.baseUrl + "/api/species?";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAnimalSpecies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAnimalSpecies(<any>response_);
                } catch (e) {
                    return <Observable<AnimalSpeciesDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AnimalSpeciesDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAnimalSpecies(response: HttpResponseBase): Observable<AnimalSpeciesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AnimalSpeciesDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AnimalSpeciesDto>(<any>null);
    }

    updateAnimalSpecies(command: UpdateAnimalSpeciesCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/species";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAnimalSpecies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAnimalSpecies(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAnimalSpecies(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    updateAnimalSpeciesStatus(speciesId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/species?";
        if (speciesId === null)
            throw new Error("The parameter 'speciesId' cannot be null.");
        else if (speciesId !== undefined)
            url_ += "speciesId=" + encodeURIComponent("" + speciesId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAnimalSpeciesStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAnimalSpeciesStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAnimalSpeciesStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    deleteAnimalSpecies(speciesId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/species?";
        if (speciesId === null)
            throw new Error("The parameter 'speciesId' cannot be null.");
        else if (speciesId !== undefined)
            url_ += "speciesId=" + encodeURIComponent("" + speciesId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAnimalSpecies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAnimalSpecies(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAnimalSpecies(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TemplateService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTemplates(): Observable<MedicalRecordTextTemplate[]> {
        let url_ = this.baseUrl + "/api/text-templates/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplates(<any>response_);
                } catch (e) {
                    return <Observable<MedicalRecordTextTemplate[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MedicalRecordTextTemplate[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTemplates(response: HttpResponseBase): Observable<MedicalRecordTextTemplate[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MedicalRecordTextTemplate[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MedicalRecordTextTemplate[]>(<any>null);
    }

    getTemplate(templateId: string): Observable<MedicalRecordTextTemplate> {
        let url_ = this.baseUrl + "/api/text-templates/{templateId}";
        if (templateId === undefined || templateId === null)
            throw new Error("The parameter 'templateId' must be defined.");
        url_ = url_.replace("{templateId}", encodeURIComponent("" + templateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplate(<any>response_);
                } catch (e) {
                    return <Observable<MedicalRecordTextTemplate>><any>_observableThrow(e);
                }
            } else
                return <Observable<MedicalRecordTextTemplate>><any>_observableThrow(response_);
        }));
    }

    protected processGetTemplate(response: HttpResponseBase): Observable<MedicalRecordTextTemplate> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MedicalRecordTextTemplate>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MedicalRecordTextTemplate>(<any>null);
    }

    deleteTemplate(templateId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/text-templates/{templateId}";
        if (templateId === undefined || templateId === null)
            throw new Error("The parameter 'templateId' must be defined.");
        url_ = url_.replace("{templateId}", encodeURIComponent("" + templateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTemplate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTemplate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    createTemplate(command: CreateMedicalRecordTextTemplateCommand): Observable<MedicalRecordTextTemplate> {
        let url_ = this.baseUrl + "/api/text-templates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTemplate(<any>response_);
                } catch (e) {
                    return <Observable<MedicalRecordTextTemplate>><any>_observableThrow(e);
                }
            } else
                return <Observable<MedicalRecordTextTemplate>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTemplate(response: HttpResponseBase): Observable<MedicalRecordTextTemplate> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MedicalRecordTextTemplate>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MedicalRecordTextTemplate>(<any>null);
    }

    updateTemplate(command: UpdateMedicalRecordTextTemplateCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/text-templates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTemplate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTemplate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TherapiaService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    searchTherapia(searchParam: string | null | undefined): Observable<TherapiaForSelectDto[]> {
        let url_ = this.baseUrl + "/api/therapias/search?";
        if (searchParam !== undefined && searchParam !== null)
            url_ += "searchParam=" + encodeURIComponent("" + searchParam) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchTherapia(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchTherapia(<any>response_);
                } catch (e) {
                    return <Observable<TherapiaForSelectDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapiaForSelectDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processSearchTherapia(response: HttpResponseBase): Observable<TherapiaForSelectDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TherapiaForSelectDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapiaForSelectDto[]>(<any>null);
    }

    getTherapias(pageSize: number | undefined, pageIndex: number | undefined): Observable<PagedListOfTherapiaDto> {
        let url_ = this.baseUrl + "/api/therapias?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTherapias(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTherapias(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfTherapiaDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListOfTherapiaDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTherapias(response: HttpResponseBase): Observable<PagedListOfTherapiaDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PagedListOfTherapiaDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListOfTherapiaDto>(<any>null);
    }

    createTherapia(data: CreateTherapiaCommandData): Observable<TherapiaDto> {
        let url_ = this.baseUrl + "/api/therapias";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTherapia(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTherapia(<any>response_);
                } catch (e) {
                    return <Observable<TherapiaDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapiaDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTherapia(response: HttpResponseBase): Observable<TherapiaDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TherapiaDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapiaDto>(<any>null);
    }

    updateTherapia(data: UpdateTherapiaCommandData): Observable<void> {
        let url_ = this.baseUrl + "/api/therapias";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTherapia(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTherapia(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTherapia(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    updateTherapiaStatus(therapiaId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/therapias?";
        if (therapiaId === null)
            throw new Error("The parameter 'therapiaId' cannot be null.");
        else if (therapiaId !== undefined)
            url_ += "therapiaId=" + encodeURIComponent("" + therapiaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTherapiaStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTherapiaStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTherapiaStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    deleteTherapia(therapiaId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/therapias?";
        if (therapiaId === null)
            throw new Error("The parameter 'therapiaId' cannot be null.");
        else if (therapiaId !== undefined)
            url_ += "therapiaId=" + encodeURIComponent("" + therapiaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTherapia(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTherapia(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTherapia(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TreatmentService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTreatmentsDoctorId(doctorId: string): Observable<TreatmentDto[]> {
        let url_ = this.baseUrl + "/api/treatments/user/{doctorId}";
        if (doctorId === undefined || doctorId === null)
            throw new Error("The parameter 'doctorId' must be defined.");
        url_ = url_.replace("{doctorId}", encodeURIComponent("" + doctorId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTreatmentsDoctorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTreatmentsDoctorId(<any>response_);
                } catch (e) {
                    return <Observable<TreatmentDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreatmentDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTreatmentsDoctorId(response: HttpResponseBase): Observable<TreatmentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TreatmentDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreatmentDto[]>(<any>null);
    }

    getAllTreatmentsByDoctorId(doctorId: string): Observable<TreatmentDto[]> {
        let url_ = this.baseUrl + "/api/treatments/doctor/{doctorId}";
        if (doctorId === undefined || doctorId === null)
            throw new Error("The parameter 'doctorId' must be defined.");
        url_ = url_.replace("{doctorId}", encodeURIComponent("" + doctorId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTreatmentsByDoctorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTreatmentsByDoctorId(<any>response_);
                } catch (e) {
                    return <Observable<TreatmentDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreatmentDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTreatmentsByDoctorId(response: HttpResponseBase): Observable<TreatmentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TreatmentDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreatmentDto[]>(<any>null);
    }

    createTreatment(data: CreateTreatmentCommandData): Observable<TreatmentDto> {
        let url_ = this.baseUrl + "/api/treatments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTreatment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTreatment(<any>response_);
                } catch (e) {
                    return <Observable<TreatmentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreatmentDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTreatment(response: HttpResponseBase): Observable<TreatmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TreatmentDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreatmentDto>(<any>null);
    }

    updateTreatment(data: UpdateTreatmentCommandData): Observable<void> {
        let url_ = this.baseUrl + "/api/treatments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTreatment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTreatment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTreatment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    updateTreatmentStatus(treatmentId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/treatments?";
        if (treatmentId === null)
            throw new Error("The parameter 'treatmentId' cannot be null.");
        else if (treatmentId !== undefined)
            url_ += "treatmentId=" + encodeURIComponent("" + treatmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTreatmentStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTreatmentStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTreatmentStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    deleteTreatment(treatmentId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/treatments?";
        if (treatmentId === null)
            throw new Error("The parameter 'treatmentId' cannot be null.");
        else if (treatmentId !== undefined)
            url_ += "treatmentId=" + encodeURIComponent("" + treatmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTreatment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTreatment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTreatment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TreatmentIntervalService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTreatmentIntervalsWithDetails(treatmentId: string, pageSize: number | undefined, pageIndex: number | undefined): Observable<PagedListOfTreatmentIntervalDetailsDto> {
        let url_ = this.baseUrl + "/api/treatment-intervals/list/{treatmentId}?";
        if (treatmentId === undefined || treatmentId === null)
            throw new Error("The parameter 'treatmentId' must be defined.");
        url_ = url_.replace("{treatmentId}", encodeURIComponent("" + treatmentId));
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTreatmentIntervalsWithDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTreatmentIntervalsWithDetails(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfTreatmentIntervalDetailsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListOfTreatmentIntervalDetailsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTreatmentIntervalsWithDetails(response: HttpResponseBase): Observable<PagedListOfTreatmentIntervalDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PagedListOfTreatmentIntervalDetailsDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListOfTreatmentIntervalDetailsDto>(<any>null);
    }

    getTreatmentIntervalDays(treatmentId: string): Observable<number[]> {
        let url_ = this.baseUrl + "/api/treatment-intervals/interval-days/{treatmentId}";
        if (treatmentId === undefined || treatmentId === null)
            throw new Error("The parameter 'treatmentId' must be defined.");
        url_ = url_.replace("{treatmentId}", encodeURIComponent("" + treatmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTreatmentIntervalDays(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTreatmentIntervalDays(<any>response_);
                } catch (e) {
                    return <Observable<number[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<number[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTreatmentIntervalDays(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(<any>null);
    }

    createTreatmentInterval(doctorId: string | undefined, data: CreateTreatmentIntervalCommandData): Observable<TreatmentIntervalDetailsDto> {
        let url_ = this.baseUrl + "/api/treatment-intervals?";
        if (doctorId === null)
            throw new Error("The parameter 'doctorId' cannot be null.");
        else if (doctorId !== undefined)
            url_ += "doctorId=" + encodeURIComponent("" + doctorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTreatmentInterval(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTreatmentInterval(<any>response_);
                } catch (e) {
                    return <Observable<TreatmentIntervalDetailsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreatmentIntervalDetailsDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTreatmentInterval(response: HttpResponseBase): Observable<TreatmentIntervalDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TreatmentIntervalDetailsDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreatmentIntervalDetailsDto>(<any>null);
    }

    updateTreatmentInterval(doctorId: string | undefined, data: UpdateTreatmentIntervalCommandData): Observable<void> {
        let url_ = this.baseUrl + "/api/treatment-intervals?";
        if (doctorId === null)
            throw new Error("The parameter 'doctorId' cannot be null.");
        else if (doctorId !== undefined)
            url_ += "doctorId=" + encodeURIComponent("" + doctorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTreatmentInterval(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTreatmentInterval(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTreatmentInterval(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    updateTreatmentIntervalStatus(treatmentIntervalId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/treatment-intervals?";
        if (treatmentIntervalId === null)
            throw new Error("The parameter 'treatmentIntervalId' cannot be null.");
        else if (treatmentIntervalId !== undefined)
            url_ += "treatmentIntervalId=" + encodeURIComponent("" + treatmentIntervalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTreatmentIntervalStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTreatmentIntervalStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTreatmentIntervalStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    deleteTreatmentInterval(vaccineId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/treatment-intervals?";
        if (vaccineId === null)
            throw new Error("The parameter 'vaccineId' cannot be null.");
        else if (vaccineId !== undefined)
            url_ += "vaccineId=" + encodeURIComponent("" + vaccineId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTreatmentInterval(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTreatmentInterval(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTreatmentInterval(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class VaccinesService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    searchVaccines(param: string | null | undefined): Observable<VaccineSearchResultDto[]> {
        let url_ = this.baseUrl + "/api/vaccines/search?";
        if (param !== undefined && param !== null)
            url_ += "param=" + encodeURIComponent("" + param) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchVaccines(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchVaccines(<any>response_);
                } catch (e) {
                    return <Observable<VaccineSearchResultDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<VaccineSearchResultDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processSearchVaccines(response: HttpResponseBase): Observable<VaccineSearchResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <VaccineSearchResultDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VaccineSearchResultDto[]>(<any>null);
    }

    getVaccine(vaccineId: string | undefined): Observable<VaccineDto> {
        let url_ = this.baseUrl + "/api/vaccines?";
        if (vaccineId === null)
            throw new Error("The parameter 'vaccineId' cannot be null.");
        else if (vaccineId !== undefined)
            url_ += "vaccineId=" + encodeURIComponent("" + vaccineId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVaccine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVaccine(<any>response_);
                } catch (e) {
                    return <Observable<VaccineDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<VaccineDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetVaccine(response: HttpResponseBase): Observable<VaccineDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <VaccineDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VaccineDto>(<any>null);
    }

    createVaccine(name: string | null | undefined): Observable<VaccineDto> {
        let url_ = this.baseUrl + "/api/vaccines?";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateVaccine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateVaccine(<any>response_);
                } catch (e) {
                    return <Observable<VaccineDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<VaccineDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateVaccine(response: HttpResponseBase): Observable<VaccineDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <VaccineDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VaccineDto>(<any>null);
    }

    updateVaccine(command: UpdateVaccineCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/vaccines";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVaccine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVaccine(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateVaccine(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    updateVaccineStatus(vaccineId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/vaccines?";
        if (vaccineId === null)
            throw new Error("The parameter 'vaccineId' cannot be null.");
        else if (vaccineId !== undefined)
            url_ += "vaccineId=" + encodeURIComponent("" + vaccineId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVaccineStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVaccineStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateVaccineStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    deleteVaccine(vaccineId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/vaccines?";
        if (vaccineId === null)
            throw new Error("The parameter 'vaccineId' cannot be null.");
        else if (vaccineId !== undefined)
            url_ += "vaccineId=" + encodeURIComponent("" + vaccineId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteVaccine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVaccine(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteVaccine(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getVaccines(): Observable<VaccineDto[]> {
        let url_ = this.baseUrl + "/api/vaccines/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVaccines(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVaccines(<any>response_);
                } catch (e) {
                    return <Observable<VaccineDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<VaccineDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetVaccines(response: HttpResponseBase): Observable<VaccineDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <VaccineDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VaccineDto[]>(<any>null);
    }

    getVaccineRecords(animalId: string, pageSize: number | undefined, pageIndex: number | undefined): Observable<PagedListOfVaccineRecordDto> {
        let url_ = this.baseUrl + "/api/vaccines/records/{animalId}?";
        if (animalId === undefined || animalId === null)
            throw new Error("The parameter 'animalId' must be defined.");
        url_ = url_.replace("{animalId}", encodeURIComponent("" + animalId));
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVaccineRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVaccineRecords(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfVaccineRecordDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListOfVaccineRecordDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetVaccineRecords(response: HttpResponseBase): Observable<PagedListOfVaccineRecordDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PagedListOfVaccineRecordDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListOfVaccineRecordDto>(<any>null);
    }

    getVaccineRecord(recordId: string): Observable<VaccineRecordDto> {
        let url_ = this.baseUrl + "/api/vaccines/record/{recordId}";
        if (recordId === undefined || recordId === null)
            throw new Error("The parameter 'recordId' must be defined.");
        url_ = url_.replace("{recordId}", encodeURIComponent("" + recordId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVaccineRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVaccineRecord(<any>response_);
                } catch (e) {
                    return <Observable<VaccineRecordDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<VaccineRecordDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetVaccineRecord(response: HttpResponseBase): Observable<VaccineRecordDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <VaccineRecordDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VaccineRecordDto>(<any>null);
    }

    createVaccineRecord(data: CreateVaccineRecordCommandData): Observable<VaccineRecordDto> {
        let url_ = this.baseUrl + "/api/vaccines/record";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateVaccineRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateVaccineRecord(<any>response_);
                } catch (e) {
                    return <Observable<VaccineRecordDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<VaccineRecordDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateVaccineRecord(response: HttpResponseBase): Observable<VaccineRecordDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <VaccineRecordDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VaccineRecordDto>(<any>null);
    }

    updateVaccineRecord(data: UpdateVaccineRecordCommandData): Observable<void> {
        let url_ = this.baseUrl + "/api/vaccines/record";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVaccineRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVaccineRecord(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateVaccineRecord(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    deleteVaccineRecord(vaccineRecordId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/vaccines/record?";
        if (vaccineRecordId === null)
            throw new Error("The parameter 'vaccineRecordId' cannot be null.");
        else if (vaccineRecordId !== undefined)
            url_ += "vaccineRecordId=" + encodeURIComponent("" + vaccineRecordId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteVaccineRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVaccineRecord(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteVaccineRecord(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getPhotoUrl(userId: string): Observable<string> {
        let url_ = this.baseUrl + "/api/users/get-photo-url/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPhotoUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPhotoUrl(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetPhotoUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    deletePhoto(userId: string): Observable<string> {
        let url_ = this.baseUrl + "/api/users/delete-photo/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePhoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePhoto(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePhoto(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    uploadPhoto(userId: string | undefined, photo: FileParameter | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/users/upload-photo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (userId === null || userId === undefined)
            throw new Error("The parameter 'userId' cannot be null.");
        else
            content_.append("UserId", userId.toString());
        if (photo !== null && photo !== undefined)
            content_.append("Photo", photo.data, photo.fileName ? photo.fileName : "Photo");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadPhoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadPhoto(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUploadPhoto(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    searchUsers(param: string | null | undefined): Observable<VeterinaryUserDto[]> {
        let url_ = this.baseUrl + "/api/users/search?";
        if (param !== undefined && param !== null)
            url_ += "param=" + encodeURIComponent("" + param) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchUsers(<any>response_);
                } catch (e) {
                    return <Observable<VeterinaryUserDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<VeterinaryUserDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processSearchUsers(response: HttpResponseBase): Observable<VeterinaryUserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <VeterinaryUserDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VeterinaryUserDto[]>(<any>null);
    }

    searchUsersPaged(searchParam: string | null | undefined, pageData_PageSize: number | undefined, pageData_PageIndex: number | undefined): Observable<PagedListOfVeterinaryUserDto> {
        let url_ = this.baseUrl + "/api/users/search-paged?";
        if (searchParam !== undefined && searchParam !== null)
            url_ += "SearchParam=" + encodeURIComponent("" + searchParam) + "&";
        if (pageData_PageSize === null)
            throw new Error("The parameter 'pageData_PageSize' cannot be null.");
        else if (pageData_PageSize !== undefined)
            url_ += "PageData.PageSize=" + encodeURIComponent("" + pageData_PageSize) + "&";
        if (pageData_PageIndex === null)
            throw new Error("The parameter 'pageData_PageIndex' cannot be null.");
        else if (pageData_PageIndex !== undefined)
            url_ += "PageData.PageIndex=" + encodeURIComponent("" + pageData_PageIndex) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchUsersPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchUsersPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfVeterinaryUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListOfVeterinaryUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processSearchUsersPaged(response: HttpResponseBase): Observable<PagedListOfVeterinaryUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PagedListOfVeterinaryUserDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListOfVeterinaryUserDto>(<any>null);
    }

    getUser(userId: string): Observable<VeterinaryUserDto> {
        let url_ = this.baseUrl + "/api/users/user/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUser(<any>response_);
                } catch (e) {
                    return <Observable<VeterinaryUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<VeterinaryUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUser(response: HttpResponseBase): Observable<VeterinaryUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <VeterinaryUserDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VeterinaryUserDto>(<any>null);
    }

    getDoctorsWithRole(): Observable<DoctorWithRoleDto[]> {
        let url_ = this.baseUrl + "/api/users/doctors";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDoctorsWithRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDoctorsWithRole(<any>response_);
                } catch (e) {
                    return <Observable<DoctorWithRoleDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DoctorWithRoleDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDoctorsWithRole(response: HttpResponseBase): Observable<DoctorWithRoleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DoctorWithRoleDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DoctorWithRoleDto[]>(<any>null);
    }

    changeUserRole(userId: string | undefined, roleName: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/users/role?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (roleName !== undefined && roleName !== null)
            url_ += "RoleName=" + encodeURIComponent("" + roleName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUserRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUserRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeUserRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export interface PagedListOfOwnedAnimalDto {
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;
    items?: OwnedAnimalDto[] | undefined;
}

export interface OwnedAnimalDto {
    id?: string;
    name?: string | undefined;
    dateOfBirth?: Date;
    age?: string | undefined;
    sex?: string | undefined;
    speciesName?: string | undefined;
    subSpeciesName?: string | undefined;
    photoUrl?: string | undefined;
}

export interface AnimalForSelectDto {
    id?: string;
    name?: string | undefined;
}

export interface UpdateAnimalCommandData {
    name?: string | undefined;
    dateOfBirth?: Date | undefined;
    sex?: string | undefined;
    speciesId?: string;
    subSpecies?: string | undefined;
    weight?: number;
}

export interface AnimalDto {
    id?: string;
    name?: string | undefined;
    dateOfBirth?: Date;
    age?: string | undefined;
    sex?: string | undefined;
    weight?: number;
    speciesId?: string;
    subSpeciesName?: string | undefined;
    photoUrl?: string | undefined;
    ownerId?: string;
}

export interface LabelValuePairOfAppointmentStatusEnum {
    label?: string | undefined;
    value?: AppointmentStatusEnum;
}

export enum AppointmentStatusEnum {
    New = 0,
    Arrived = 1,
    Closed = 2,
    Resigned = 3,
    ResignedByDoctor = 4,
    Other = 5,
}

export interface DoctorForAppointmentDto {
    id?: string;
    name?: string | undefined;
}

export interface AvailableTime {
    id?: number;
    startTime?: Date;
    endTime?: Date;
}

export interface CreateAppointmentCommand {
    startDate?: Date;
    endDate?: Date;
    treatmentId?: string;
    doctorId?: string;
    ownerId?: string | undefined;
    animalId?: string | undefined;
    reasons?: string | undefined;
}

export interface PagedListOfAppointmentForDoctorDto {
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;
    items?: AppointmentForDoctorDto[] | undefined;
}

export interface AppointmentForDoctorDto {
    id?: string;
    userId?: string;
    userName?: string | undefined;
    treatmentId?: string;
    treatmentName?: string | undefined;
    animalId?: string | undefined;
    animalName?: string | undefined;
    animalSpecies?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    reasons?: string | undefined;
    status?: AppointmentStatusEnum;
}

export interface PagedListOfAppointmentForUserDto {
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;
    items?: AppointmentForUserDto[] | undefined;
}

export interface AppointmentForUserDto {
    id?: string;
    doctorId?: string;
    doctorName?: string | undefined;
    treatmentId?: string;
    treatmentName?: string | undefined;
    animalId?: string | undefined;
    animalName?: string | undefined;
    animalSpecies?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    reasons?: string | undefined;
    status?: AppointmentStatusEnum;
}

export interface UpdateAppointmentStatusCommand {
    appointmentId?: string;
    statusId?: number;
}

export interface PagedListOfHolidayDto {
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;
    items?: HolidayDto[] | undefined;
}

export interface HolidayDto {
    id?: string;
    doctorId?: string;
    startDate?: Date;
    endDate?: Date;
}

export interface CreateHolidayCommandData {
    doctorId?: string;
    startDate?: Date;
    endDate?: Date;
}

export interface UpdateHolidayCommandData {
    holidayId?: string;
    startDate?: Date;
    endDate?: Date;
}

export interface PagedListOfMedicalRecordDto {
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;
    items?: MedicalRecordDto[] | undefined;
}

export interface MedicalRecordDto {
    id?: string;
    date?: Date;
    doctorId?: string;
    doctorName?: string | undefined;
    animalId?: string | undefined;
    animalName?: string | undefined;
    ownerEmail?: string | undefined;
    ownerId?: string | undefined;
    ownerName?: string | undefined;
    htmlContent?: string | undefined;
    photoUrls?: string[] | undefined;
    medicationRecords?: MedicationRecordOnRecord[] | undefined;
    therapiaRecords?: TherapiaRecordOnRecord[] | undefined;
}

export interface MedicationRecordOnRecord {
    medicationId?: string;
    name?: string | undefined;
    amount?: number;
    unitName?: string | undefined;
}

export interface TherapiaRecordOnRecord {
    therapiaId?: string;
    name?: string | undefined;
    amount?: number;
}

export interface MedicalRecordEditDto {
    id?: string;
    date?: Date;
    doctorId?: string;
    ownerEmail?: string | undefined;
    ownerId?: string | undefined;
    animalId?: string | undefined;
    htmlContent?: string | undefined;
    medicationRecords?: MedicationForRecordEditDto[] | undefined;
    therapiaRecords?: TherapiaForRecordEditDto[] | undefined;
    photoUrls?: PhotoOnRecord[] | undefined;
}

export interface MedicationForRecordEditDto {
    id?: string;
    name?: string | undefined;
    amount?: number;
    unitName?: string | undefined;
}

export interface TherapiaForRecordEditDto {
    id?: string;
    name?: string | undefined;
    amount?: number;
}

export interface PhotoOnRecord {
    id?: string;
    photoUrl?: string | undefined;
}

export interface AppointmentForRecordDto {
    ownerId?: string;
    ownerEmail?: string | undefined;
    animalId?: string | undefined;
    animalName?: string | undefined;
}

export interface CreateMedicalRecordCommand {
    data?: CreateMedicalRecordCommandData | undefined;
    medications?: EditMedicationRecordDto[] | undefined;
    therapias?: EditTherapiaRecordDto[] | undefined;
}

export interface CreateMedicalRecordCommandData {
    date?: Date;
    ownerEmail?: string | undefined;
    ownerId?: string | undefined;
    animalId?: string | undefined;
    htmlContent?: string | undefined;
}

export interface EditMedicationRecordDto {
    id?: string;
    amount?: number;
}

export interface EditTherapiaRecordDto {
    id?: string;
    amount?: number;
}

export interface UpdateMedicalRecordCommand {
    medicalRecordId?: string;
    data?: UpdateMedicalRecordCommandData | undefined;
    medications?: EditMedicationRecordDto[] | undefined;
    therapias?: EditTherapiaRecordDto[] | undefined;
}

export interface UpdateMedicalRecordCommandData {
    date?: Date;
    ownerEmail?: string | undefined;
    ownerId?: string | undefined;
    animalId?: string | undefined;
    htmlContent?: string | undefined;
}

export interface MedicationForSelectDto {
    id?: string;
    name?: string | undefined;
    unitName?: string | undefined;
}

export interface PagedListOfMedicationDto {
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;
    items?: MedicationDto[] | undefined;
}

export interface MedicationDto {
    id?: string;
    name?: string | undefined;
    unitName?: string | undefined;
    unit?: number;
    pricePerUnit?: number;
    isInactive?: boolean;
}

export interface CreateMedicationCommandData {
    name?: string | undefined;
    unitName?: string | undefined;
    unit?: number;
    pricePerUnit?: number;
}

export interface UpdateMedicationCommandData {
    id?: string;
    name?: string | undefined;
    unitName?: string | undefined;
    unit?: number;
    pricePerUnit?: number;
}

export interface AnimalSpeciesDto {
    id?: string;
    name?: string | undefined;
    isInactive?: boolean;
}

export interface UpdateAnimalSpeciesCommand {
    id?: string;
    name?: string | undefined;
}

export interface MedicalRecordTextTemplate {
    id?: string;
    name?: string | undefined;
    htmlContent?: string | undefined;
}

export interface CreateMedicalRecordTextTemplateCommand {
    name?: string | undefined;
    htmlContent?: string | undefined;
}

export interface UpdateMedicalRecordTextTemplateCommand {
    templateId?: string;
    name?: string | undefined;
    htmlContent?: string | undefined;
}

export interface TherapiaForSelectDto {
    id?: string;
    name?: string | undefined;
}

export interface PagedListOfTherapiaDto {
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;
    items?: TherapiaDto[] | undefined;
}

export interface TherapiaDto {
    id?: string;
    name?: string | undefined;
    price?: number;
    isInactive?: boolean;
}

export interface CreateTherapiaCommandData {
    name?: string | undefined;
    price?: number;
}

export interface UpdateTherapiaCommandData {
    id?: string;
    name?: string | undefined;
    price?: number;
}

export interface TreatmentDto {
    id?: string;
    name?: string | undefined;
    duration?: number;
    isInactive?: boolean;
}

export interface CreateTreatmentCommandData {
    name?: string | undefined;
    duration?: number;
}

export interface UpdateTreatmentCommandData {
    treatmentId?: string;
    name?: string | undefined;
    duration?: number;
}

export interface PagedListOfTreatmentIntervalDetailsDto {
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;
    items?: TreatmentIntervalDetailsDto[] | undefined;
}

export interface TreatmentIntervalDetailsDto {
    id?: string;
    startHour?: number;
    startMin?: number;
    endHour?: number;
    endMin?: number;
    dayOfWeek?: number;
    isInactive?: boolean;
    treatmentId?: string;
}

export interface CreateTreatmentIntervalCommandData {
    startHour?: number;
    startMin?: number;
    endHour?: number;
    endMin?: number;
    dayOfWeek?: number;
    treatmentId?: string;
}

export interface UpdateTreatmentIntervalCommandData {
    id?: string;
    startHour?: number;
    startMin?: number;
    endHour?: number;
    endMin?: number;
    dayOfWeek?: number;
}

export interface VaccineSearchResultDto {
    id?: string;
    name?: string | undefined;
}

export interface VaccineDto {
    id?: string;
    name?: string | undefined;
    isInactive?: boolean;
}

export interface UpdateVaccineCommand {
    id?: string;
    name?: string | undefined;
}

export interface PagedListOfVaccineRecordDto {
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;
    items?: VaccineRecordDto[] | undefined;
}

export interface VaccineRecordDto {
    id?: string;
    date?: Date;
    vaccineId?: string;
    vaccineName?: string | undefined;
    animalId?: string;
    animalName?: string | undefined;
}

export interface CreateVaccineRecordCommandData {
    date?: Date;
    animalId?: string;
    vaccineId?: string;
}

export interface UpdateVaccineRecordCommandData {
    id?: string;
    date?: Date;
    animalId?: string;
    vaccineId?: string;
}

export interface VeterinaryUserDto {
    id?: string;
    name?: string | undefined;
    email?: string | undefined;
    address?: string | undefined;
    phoneNumber?: string | undefined;
    photoUrl?: string | undefined;
}

export interface PagedListOfVeterinaryUserDto {
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;
    items?: VeterinaryUserDto[] | undefined;
}

export interface DoctorWithRoleDto {
    id?: string;
    name?: string | undefined;
    email?: string | undefined;
    role?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}